
# Hello, world!

```asm
// Пример ассемблерной вставки Plan9
#include "textflag.h"

TEXT ·hello_world(SB),NOSPLIT,$0
    MOVQ    $1, AX
    MOVQ    $1, DI
    LEAQ    text<>(SB), SI
    MOVQ    $14, DX
    SYSCALL
    RET

DATA text<>+0(SB)/14, $"Hello, world!\n"
GLOBL text<>(SB), RODATA, $14
```

Разберём код построчно с объяснением синтаксиса Plan9 assembler для Go:

---

### 1. `#include "textflag.h"`
**Что делает**: Подключает заголовочный файл Go, содержащий макросы для флагов (например, `NOSPLIT`).  
**Зачем нужно**: Для использования констант вроде `NOSPLIT`, которые управляют поведением компилятора.

---

### 2. `TEXT ·hello_world(SB),NOSPLIT,$0`
**Структура**:
- `TEXT` — объявляет функцию.
- `·hello_world` — имя функции (символ `·` разделяет пакет и имя функции).
- `(SB)` — Static Base (базовый адрес для символа).
- `NOSPLIT` — флаг, запрещающий компилятору добавлять пролог/эпилог для управления стеком.
- `$0` — размер локального стека (0 байт).

**Пример на Go**: Эквивалентно объявлению `func hello_world()` в Go-коде.

---

### 3. `MOVQ $1, AX`
**Что делает**: Загружает значение `1` в регистр `AX`.  
**Зачем**: 
- `AX` хранит номер системного вызова:
  - `1` = `sys_write` (запись в файловый дескриптор).
- В Plan9 регистры называются без префикса `R` (AX вместо RAX).

---

### 4. `MOVQ $1, DI`
**Что делает**: Загружает `1` в регистр `DI`.  
**Зачем**: 
- `DI` хранит файловый дескриптор:
  - `1` = стандартный вывод (stdout).

---

### 5. `LEAQ text<>(SB), SI`
**Что делает**: Загружает адрес метки `text<>` в регистр `SI`.  
**Зачем**: 
- `SI` хранит указатель на данные (адрес строки "Hello, world!\n").
- `text<>(SB)` — обращение к локальной метке данных.

---

### 6. `MOVQ $14, DX`
**Что делает**: Загружает `14` в регистр `DX`.  
**Зачем**: 
- `DX` хранит длину строки:
  - `14` = 13 символов ("Hello, world!") + `\n` (1 символ).

---

### 7. `SYSCALL`
**Что делает**: Выполняет системный вызов.  
**Зачем**: 
- Вызывает `sys_write` с параметрами:
  - Файловый дескриптор = 1 (stdout)
  - Адрес строки = `text<>`
  - Длина = 13.

---

### 8. `RET`
**Что делает**: Возврат из функции.  
**Зачем**: Завершает выполнение `hello_world()`.

---

### 9. `DATA text<>+0(SB)/14, $"Hello, world!\n"`
**Что делает**: 
- Определяет данные для метки `text<>`:
  - `+0` — смещение от начала метки.
  - `/14` — размер блока (14 байт).
  - `"Hello, world!\n"` — первые 14 символов строки.

---

### 10. `GLOBL text<>(SB), RODATA, $14`
**Что делает**: 
- Объявляет метку `text<>` как глобальную:
  - `RODATA` — данные только для чтения.
  - `$14` — общий размер данных.

---

### Схема работы
1. Функция `hello_world` вызывает системный вызов `write`.
2. Параметры вызова:
   - Куда: stdout (1)
   - Что: строка "Hello, world!\n"
   - Длина: 14 байт
3. Результат: вывод текста в консоль.

---

### Особенности Plan9 assembler
1. **Регистры**: Используются 64-битные регистры, но без префикса `R` (AX вместо RAX).
2. **Метки**: 
   - `·`  (точка-посередине, Unicode U+00B7) в имени функции — связь с Go-кодом.
   - `(SB)` — обязательный суффикс для всех глобальных символов.
3. **Данные**: Строки разбиваются на блоки с явным указанием размера.

---

### Как проверить
```bash
# Сборка для Linux x86-64
GOOS=linux GOARCH=amd64 go build -o bin/hello
bin/hello
```

```bash
# Сборка Docker-образа
make build
make run
```

Вывод:
```
Hello, world!
```
